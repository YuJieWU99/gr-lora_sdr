#!/usr/bin/env python
# -*- coding: utf-8 -*-
#                     GNU GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.


from gnuradio import gr, gr_unittest
from gnuradio import blocks
from numpy import array
from whitening_sequence import code
import pmt
import numpy as np
from functools import reduce


# from gnuradio import blocks
try:
    import gnuradio.lora_sdr as lora_sdr
   
except ImportError:
    import os
    import sys
    dirname, filename = os.path.split(os.path.abspath(__file__))
    sys.path.append(os.path.join(dirname, "bindings"))

def make_tag(key, value, offset, srcid=None):
    tag = gr.tag_t()
    tag.key = pmt.string_to_symbol(key)
    tag.value = value
    tag.offset = offset
    if srcid is not None:
        tag.srcid = pmt.to_pmt(srcid)
    return tag


def int_to_bool(value, num_bits):

    return [(value >> i) & 1 for i in range(num_bits - 1, -1, -1)]

def bool_to_int(b):
    return reduce(lambda x, y: (x << 1) + y, b, 0)

def hard_coding(in_data, cr_app):
    out_data = []

    for i in range(len(in_data)):
        data_nibble = [False] * 4
        s0, s1, s2 = False, False, False
        syndrom = 0

        codeword = int_to_bool(in_data[i], cr_app + 4)
        
        data_nibble = [codeword[3], codeword[2], codeword[1], codeword[0]]  # reorganized msb-first

        if cr_app == 4:
            if not (sum(codeword) % 2): 
                continue

        elif cr_app == 3:
            # get syndrom
            s0 = codeword[0] ^ codeword[1] ^ codeword[2] ^ codeword[4]
            s1 = codeword[1] ^ codeword[2] ^ codeword[3] ^ codeword[5]
            s2 = codeword[0] ^ codeword[1] ^ codeword[3] ^ codeword[6]

            syndrom = s0 + (s1 << 1) + (s2 << 2)

            if syndrom == 5:
                data_nibble[3] = not data_nibble[3]
            elif syndrom == 7:
                data_nibble[2] = not data_nibble[2]
            elif syndrom == 3:
                data_nibble[1] = not data_nibble[1]
            elif syndrom == 6:
                data_nibble[0] = not data_nibble[0]

        elif cr_app == 2:
            s0 = codeword[0] ^ codeword[1] ^ codeword[2] ^ codeword[4]
            s1 = codeword[1] ^ codeword[2] ^ codeword[3] ^ codeword[5]

            if s0 or s1:
                pass 

        elif cr_app == 1:
            if not (sum(codeword) % 2):
                pass 

        out_data.append(bool_to_int(data_nibble))

    return out_data

class qa_hamm_dec(gr_unittest.TestCase):

    def setUp(self):
        self.tb = gr.top_block()

    def tearDown(self):
        self.tb = None

    def test_001_hard_decoding(self):

        sf = 7
        cr = 2
        # set the payload length randomly
        payload_length = 10
        # nibbles generated by whitening block is sf bits, the maximum value of the nibble is 16
        max_value = 2**sf
        # randomly generate the nibbles output by whitening block
        src_data = np.random.randint(max_value, size=payload_length)

        soft_decoding = False

        a = pmt.make_dict()
        key1 = pmt.intern("is_header")
        is_header = pmt.from_bool(False)
        key4 = pmt.intern("cr")
        sf_tag = pmt.from_long(cr)
        a = pmt.dict_add(a, key1, is_header)
        a = pmt.dict_add(a, key4, sf_tag)
        src_tag = [make_tag('frame_info',a, 0,'src_data')]
       
        is_header = False
        cr_app = 4 if is_header else cr

        lora_sdr_hamming_dec = lora_sdr.hamming_dec(soft_decoding)
        blocks_vector_source = blocks.vector_source_b(src_data, False, 1, src_tag)
        blocks_vector_sink = blocks.vector_sink_b(1, 1024)

        self.tb.connect((blocks_vector_source, 0), (lora_sdr_hamming_dec, 0))
        self.tb.connect((lora_sdr_hamming_dec, 0), (blocks_vector_sink, 0))
        self.tb.run()

        result_data = blocks_vector_sink.data()
    
        # generate reference data

        ref_out = [0] * len(src_data)
        ref_out = hard_coding(src_data, cr_app)

        self.assertEqual(ref_out, result_data)

    

if __name__ == '__main__':
    gr_unittest.run(qa_hamm_dec)
