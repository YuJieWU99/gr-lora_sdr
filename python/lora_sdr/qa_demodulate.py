#!/usr/bin/env python
# -*- coding: utf-8 -*-
#                     GNU GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.


from gnuradio import gr, gr_unittest
from gnuradio import blocks
from numpy import array
from whitening_sequence import code

import pmt
import numpy as np

# from gnuradio import blocks
try:
  import gnuradio.lora_sdr as lora_sdr
except ImportError:
    import os
    import sys
    dirname, filename = os.path.split(os.path.abspath(__file__))
    sys.path.append(os.path.join(dirname, "bindings"))
    from gnuradio.lora_sdr import fft_demod

def make_tag(key, value, offset, srcid=None):
    tag = gr.tag_t()
    tag.key = pmt.string_to_symbol(key)
    tag.value = value
    tag.offset = offset
    if srcid is not None:
        tag.srcid = pmt.to_pmt(srcid)
    return tag

def build_upchirp(chirp, id, sf, os_factor=1):
    N = 2 ** sf
    

    n_fold = int(N * os_factor - id * os_factor)
    for n in range(int(N * os_factor)):
        if n < n_fold:
            chirp[n] = 1.0 + 0.0j
            chirp[n] *= np.exp(2.0j * np.pi * (n * n / (2 * N) / (os_factor ** 2) + (id / N - 0.5) * n / os_factor))
        else:
            chirp[n] = 1.0 + 0.0j
            chirp[n] *= np.exp(2.0j * np.pi * (n * n / (2 * N) / (os_factor ** 2) + (id / N - 1.5) * n / os_factor))

def build_ref_chirps(upchirp, downchirp, sf, os_factor=1):
    N = 2 ** sf
    build_upchirp(upchirp, 0, sf, os_factor)
    for i in range(len(downchirp)):
        downchirp[i] = np.conjugate(upchirp[i])

def generate_reference_output(length, preamb_samp_cnt, output_offset, m_sync_words, m_preamb_len, m_samples_per_symbol, sf, os_factor, m_upchirp, m_downchirp, src_data):
    ref_out = [0j] * length
    if len(m_sync_words) == 1:
        tmp = m_sync_words[0]
        m_sync_words.extend([0, 0])
        m_sync_words[0] = ((tmp & 0xF0) >> 4) << 3
        m_sync_words[1] = (tmp & 0x0F) << 3

    for i in range(m_preamb_len):
        ref_out[output_offset:output_offset + m_samples_per_symbol] = m_upchirp
        
        output_offset += m_samples_per_symbol
        preamb_samp_cnt += m_samples_per_symbol

    for i in range(len(src_data)):
        temp2_chirp = [0j] * m_samples_per_symbol
        build_upchirp(temp2_chirp, src_data[i], sf, os_factor)
        ref_out[output_offset:output_offset + m_samples_per_symbol] = temp2_chirp
        output_offset += m_samples_per_symbol

    return ref_out


class qa_demodulate(gr_unittest.TestCase):

    def setUp(self):
        self.tb = gr.top_block()

    def tearDown(self):
        self.tb = None

    def test_001_hard_coding(self):

        soft_decoding = False
        sf = 7
        samp_rate = 500000
        bw = 125000
        cr = 2
        os_factor = 1 # frame_sync has done the down sampling
        ldro = False

        m_preamb_len = 8
        m_number_of_bins = 2 ** sf
        m_samples_per_symbol = m_number_of_bins
      
        output_offset = 0
        m_sync_words = [8,16]
        m_upchirp = [0j] * m_samples_per_symbol
        m_downchirp = [0j] * m_samples_per_symbol

        # set the payload (symbol) length randomly, demodulator output a block every time, a block contains 6 symbols, here should be multiples of 6.
        payload_length = 12 
        # nibbles generated by whitening block is sf bits, the maximum value of the nibble is 16
        max_value = 2**sf
        # randomly generate the nibbles output by whitening block
        ref_data = np.random.randint(max_value, size=payload_length) 
        preamble_data = [31,31,31,31,31,31,31,31] # there are 8 symbols in preamble
     
        length = (m_preamb_len + payload_length) * m_samples_per_symbol
        src_data = [0j] * length
        preamb_samp_cnt = 0

        # add tag for header
        a = pmt.make_dict()
        key1 = pmt.intern("is_header")
        is_header = pmt.from_bool(True)
        key2 = pmt.intern("cfo_int")
        cfo_int = pmt.from_long(0)
        key3 = pmt.intern("cfo_frac")
        cfo_frac = pmt.from_float(0)
        key4 = pmt.intern("sf")
        sf_tag = pmt.from_double(sf)
        a = pmt.dict_add(a, key1, is_header)
        a = pmt.dict_add(a, key2, cfo_int)
        a = pmt.dict_add(a, key3, cfo_frac)
        a = pmt.dict_add(a, key4, sf_tag)

        # add tag for information symbols
        b = pmt.make_dict()
        key1 = pmt.intern("is_header")
        is_header = pmt.from_bool(False)
        key2 = pmt.intern("cr")
        cfo_int = pmt.from_long(cr)
        key3 = pmt.intern("ldro")
        cfo_frac = pmt.from_bool(ldro)
        key4 = pmt.intern("symb_numb")
        sf_tag = pmt.from_long(payload_length)
        b = pmt.dict_add(b, key1, is_header)
        b = pmt.dict_add(b, key2, cfo_int)
        b = pmt.dict_add(b, key3, cfo_frac)
        b = pmt.dict_add(b, key4, sf_tag)

        src_tag = [make_tag('frame_info',a, 0,'src_data'), make_tag('frame_info',b, m_preamb_len*m_samples_per_symbol,'src_data')]
        
        build_ref_chirps(m_upchirp, m_downchirp, sf, os_factor)
        
        src_data = generate_reference_output(length, preamb_samp_cnt, output_offset, m_sync_words, m_preamb_len, m_samples_per_symbol, sf, os_factor, m_upchirp, m_downchirp, ref_data)

        lora_sdr_fft_demod = lora_sdr.fft_demod(soft_decoding, False)
        blocks_vector_source = blocks.vector_source_c(src_data, False, 1, src_tag)
        blocks_vector_sink = blocks.vector_sink_s(1, 1024)

        self.tb.connect((blocks_vector_source, 0), (lora_sdr_fft_demod, 0))
        self.tb.connect((lora_sdr_fft_demod, 0), (blocks_vector_sink, 0))
     
        self.tb.run()
        result_data = blocks_vector_sink.data()
        ref_data = ref_data-1
        ref_out =np.concatenate((preamble_data , ref_data), axis=0)
        print(ref_out)
        print(result_data)

        for i in range(len(ref_out)):
            self.assertEqual(result_data[i], ref_out[i])

    
    


if __name__ == '__main__':
    gr_unittest.run(qa_demodulate)
