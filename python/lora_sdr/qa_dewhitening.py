#!/usr/bin/env python
# -*- coding: utf-8 -*-
#                     GNU GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.


from gnuradio import gr, gr_unittest
from gnuradio import blocks
from numpy import array
from whitening_sequence import code

import pmt
import numpy as np

# from gnuradio import blocks
try:
    import gnuradio.lora_sdr as lora_sdr
except ImportError:
    import os
    import sys
    dirname, filename = os.path.split(os.path.abspath(__file__))
    sys.path.append(os.path.join(dirname, "bindings"))
    from gnuradio.lora_sdr import whitening

def make_tag(key, value, offset, srcid=None):
    tag = gr.tag_t()
    tag.key = pmt.string_to_symbol(key)
    tag.value = value
    tag.offset = offset
    if srcid is not None:
        tag.srcid = pmt.to_pmt(srcid)
    return tag


class qa_dewhitening(gr_unittest.TestCase):

    def setUp(self):
        self.tb = gr.top_block()

    def tearDown(self):
        self.tb = None

    def combine(self, result_data):
        return [result_data[2 * i] | (result_data[2 * i + 1] << 4) for i in range(int(len(result_data) / 2))]


    def test_001_vector_source(self):

        sf = 7
        cr = 2
        crc = 0

        # set the payload length randomly 
        payload_length = 5
        frame_len = payload_length*2
        # nibbles generated by whitening block is sf bits, the maximum value of the nibble is 16
        max_value = 15
        # randomly generate the nibbles output by whitening block
        src_data = np.random.randint(max_value, size=payload_length)

        a = pmt.make_dict()
        key1 = pmt.intern("pay_len")
        pay_len = pmt.from_long(10)
        key4 = pmt.intern("crc")
        crc_tag = pmt.from_long(crc)
        a = pmt.dict_add(a, key1, pay_len)
        a = pmt.dict_add(a, key4, crc_tag)
        src_tag = [make_tag('frame_info',a, 0,'src_data')]

        lora_sdr_dewhitening = lora_sdr.dewhitening()
        blocks_vector_source = blocks.vector_source_b(src_data, False, 1, [])
        blocks_vector_sink = blocks.vector_sink_b(1, 1024)

        self.tb.connect((blocks_vector_source, 0), (lora_sdr_dewhitening, 0))
        self.tb.connect((lora_sdr_dewhitening, 0), (blocks_vector_sink, 0))
     
        self.tb.run()
        result_data = blocks_vector_sink.data()

        print(result_data)
        m_crc_presence = False


        # generate reference data
        ref_out = [0] * frame_len
        for i in range(frame_len // 2):
            if offset < frame_len:
                low_nib = src_data[2 * i] ^ (code[offset] & 0x0F)
                high_nib = (src_data[2 * i + 1] ^ (code[offset] & 0xF0)) >> 4
                ref_out.append(high_nib << 4 | low_nib)
            elif offset < frame_len + 2 and m_crc_presence:
                # Do not dewhiten the CRC
                low_nib = src_data[2 * i]
                high_nib = src_data[2 * i + 1]
                ref_out.append(high_nib << 4 | low_nib)
            else:
                # Full packet received
                break
            offset += 1


        print(ref_out)
        self.assertEqual(result_data, ref_out)
    


if __name__ == '__main__':
    gr_unittest.run(qa_dewhitening)
